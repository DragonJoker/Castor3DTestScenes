#version 420 core

layout (vertices = 3) out;

//uniform vec3 c3d_v3CameraPosition;

in vec3 vtx_vertex[];
in vec3 vtx_normal[];
in vec3 vtx_tangent[];
in vec3 vtx_bitangent[];
in vec2 vtx_texture[];

out vec3 tc_vertex[];
out vec3 tc_normal[];
out vec3 tc_tangent[];
out vec3 tc_bitangent[];
out vec2 tc_texture[];

float GetTessLevel( float p_fDistance0, float p_fDistance1 )
 {
	float AvgDistance = (p_fDistance0 + p_fDistance1) / 2.0;

	if (AvgDistance <= 2.0)
	{
		return 10.0;
	}
	else if (AvgDistance <= 5.0)
	{
		return 7.0;
	}
	else
	{
		return 3.0;
	}
}

void main()
{
	vec3 c3d_v3CameraPosition = vec3( 0, 0, -5 );
	tc_vertex[gl_InvocationID]		= vtx_vertex[gl_InvocationID];
	tc_normal[gl_InvocationID]		= vtx_normal[gl_InvocationID];
	tc_tangent[gl_InvocationID]		= vtx_tangent[gl_InvocationID];
	tc_bitangent[gl_InvocationID]	= vtx_bitangent[gl_InvocationID];
	tc_texture[gl_InvocationID]		= vtx_texture[gl_InvocationID];
	
	// Calculate the distance from the camera to the three control points
	float l_fEyeToVertexDistance0 = distance( c3d_v3CameraPosition, tc_vertex[0] );
	float l_fEyeToVertexDistance1 = distance( c3d_v3CameraPosition, tc_vertex[1] );
	float l_fEyeToVertexDistance2 = distance( c3d_v3CameraPosition, tc_vertex[2] );

	// Calculate the tessellation levels
	gl_TessLevelOuter[0] = GetTessLevel( l_fEyeToVertexDistance1, l_fEyeToVertexDistance2 );
	gl_TessLevelOuter[1] = GetTessLevel( l_fEyeToVertexDistance2, l_fEyeToVertexDistance0 );
	gl_TessLevelOuter[2] = GetTessLevel( l_fEyeToVertexDistance0, l_fEyeToVertexDistance1 );
	gl_TessLevelInner[0] = gl_TessLevelOuter[2];
}	  
